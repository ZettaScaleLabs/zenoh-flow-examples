#
# Copyright (c) 2022 ZettaScale Technology
#
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License 2.0 which is available at
# http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
# which is available at https://www.apache.org/licenses/LICENSE-2.0.
#
# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
#
# Contributors:
#   ZettaScale Zenoh Team, <zenoh@zettascale.tech>
#


from zenoh_flow.interfaces import Operator
from zenoh_flow import Input, Output
from zenoh_flow.types import Context
import logging
from typing import Dict, Any
from dataclasses import dataclass
from pycdr2 import IdlStruct
from pycdr2.types import uint64


# CRD
@dataclass
class MyStruct(IdlStruct, typename="MyStruct"):
    u_value: uint64
    s_value: str



# Protobuf


# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: message.proto
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import symbol_database as _symbol_database
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\rmessage.proto\")\n\x05MyMsg\x12\x0f\n\x07u_value\x18\x01 \x01(\x04\x12\x0f\n\x07s_value\x18\x02 \x01(\tb\x06proto3')



_MYMSG = DESCRIPTOR.message_types_by_name['MyMsg']
MyMsg = _reflection.GeneratedProtocolMessageType('MyMsg', (_message.Message,), {
  'DESCRIPTOR' : _MYMSG,
  '__module__' : 'message_pb2'
  # @@protoc_insertion_point(class_scope:MyMsg)
  })
_sym_db.RegisterMessage(MyMsg)

if _descriptor._USE_C_DESCRIPTORS == False:

  DESCRIPTOR._options = None
  _MYMSG._serialized_start=17
  _MYMSG._serialized_end=58
# @@protoc_insertion_point(module_scope)


###

def protobuf_deserialize(b):
    msg = MyMsg()
    msg.ParseFromString(b)
    return msg


class Transcoder(Operator):
    def __init__(
        self,
        context: Context,
        configuration: Dict[str, Any],
        inputs: Dict[str, Input],
        outputs: Dict[str, Output],
    ):
        logging.basicConfig(format='%(levelname)s: %(message)s', level=logging.DEBUG)
        self.output = outputs.take("out", MyStruct  ,lambda x: x.serialize())
        self.in_stream = inputs.take("in",MyMsg , protobuf_deserialize)

        if self.in_stream is None:
            raise ValueError("No input 'in' found")
        if self.output is None:
            raise ValueError("No output 'ou' found")

    def finalize(self) -> None:
        return None

    async def iteration(self) -> None:
        data_msg = await self.in_stream.recv()
        payload = data_msg.get_data()
        print(f"Protobuf= (type: {type(payload)}) : {payload} ")
        # Transcode
        cdrMsg = MyStruct(payload.u_value, payload.s_value)

        print(f"CDR= (type: {type(cdrMsg)}) : {cdrMsg} ")
        await self.output.send(cdrMsg)

        return None


def register():
    return Transcoder